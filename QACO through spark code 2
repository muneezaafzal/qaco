package samplecode
import org.apache.spark._
import org.apache.spark.graphx.lib._
import org.apache.spark.graphx._
import org.apache.spark.rdd.RDD
import scala.util.Random
import scala.math._
import scala.io.Source
import scala.util.control.Breaks._
import shapeless._0
import breeze.math.MutablizingAdaptor.Lambda2

import breeze.linalg.split
import shapeless.ops.nat.ToInt
import scala.xml.persistent.Index
import scala.reflect.internal.Trees

object sparkcode {
  def main(args: Array[String]){
    //Initialize spark context
    val sparkConf = new SparkConf().setAppName("app1").setMaster("local[*]")
    val sc = new SparkContext(sparkConf)
    
    //make RDDs for vertices and edges from dataset
    val edge : RDD[Edge[(Int,Int)]] = sc.textFile("graph dataset").map{x=> val a= x.split(",")
    Edge(a(1).toLong,a(3).toLong,(a(0).toInt,a(2).toInt))}

   // val vertices : RDD[(VertexId,(String,String))] = sc.textFile("graph dataset").map{x=> val a= x.split(",")
  //  (a(1).toLong,("none","none"))}
   
    //Creating graph
    val defaultuser =("user", "missing")
        val graph = Graph.fromEdges(edge, defaultuser)

  
    // Initializing parameters
    val outdegree = graph.outDegrees
    val _degree = outdegree.collect().sortBy(x => x._1)
    var quntum_pheromone=Array.ofDim[Double](_degree.length)
   quntum_pheromone = quntum_pheromone.map(x=>0.7071068)
    var visibility=0.0
    var visibilitylist : List[(Int,Int,Double)] =List()
    var link_score : List[(Int,Int,Double)] =List()
    var link_pheromone : List[(Int,Int,Double)] =List()
    var edgeweight : List[(Int,Int,Int)] = List()
    

     //Finding visibility 
  for(i<-1 to graph.numEdges.toInt){
     val specificedge = edge.filter(e => e.attr._1 == i.toLong).first()
     val weight  = specificedge.attr._2
     val sourcenode = specificedge.srcId
     val targetnode = specificedge.dstId
     val degreeofsinglenode = outdegree.filter(e => e._1==targetnode).first()
   val deegreofnode = degreeofsinglenode._2
   visibility=deegreofnode.toDouble/ weight.toDouble
   visibilitylist = visibilitylist:+((sourcenode.toInt,targetnode.toInt,visibility)) 
   link_pheromone = link_pheromone:+((sourcenode.toInt,targetnode.toInt, 1.0))
   edgeweight = edgeweight:+((sourcenode.toInt, targetnode.toInt, weight))
} 

  //Calculating probability of each node
    val path_length = 30
    var fitnessofpaths : List[(Double,List[Int])]= List()
    var newlink_pheromone : List[(Int,Int,Double)] =List()
        newlink_pheromone = link_pheromone  
    
    val Nc = 2
    var i = 0
    var neighbours = graph.collectNeighbors(EdgeDirection.Out).sortBy(x => x._1)
    var randomnode = new Random()
        while(i< Nc)
     {
           
    neighbours.mapPartitions{x=>
       val nodes_list = x.toList
       var randomlist  : List[Int]= List()
       var lengthoflist = nodes_list.length

       for(i<-0 until lengthoflist)
       {
        randomlist = randomlist:+ nodes_list(i)._1.toInt
       }
       var minnode = randomlist.min
       var maxnode = randomlist.max
       var source_nodeid = (Math.random() * (maxnode - minnode + 1) + minnode).toInt
       var newlist = nodes_list.filter(e => e._1 == source_nodeid)
       var source_node = newlist.head
           var path : List[Int] = List()
          path = path:+ source_node._1.toInt
          var totaloutdegree = 0
          var fitness =0.0
          var totalpheromone = 0.0
          var divider = 0.0  
         for(j<- 0 to path_length-1){
          var denominator =0.0
          var probabilityofnode : List[(Double,Int)]=List()
          val visibilitylistofspecificnodeedges = visibilitylist.filter(x=>x._1 == source_node._1)
          source_node._2.map{x=>
       val   neighbournode=x._1
         val visi=  visibilitylistofspecificnodeedges.filter(x=>x._2== neighbournode )
        denominator = denominator + (quntum_pheromone(x._1.toInt-1) * link_pheromone(0)._3 * visi(0)._3 ) 
         }
         source_node._2.map{ x=>
             
         val firstnode=x._1
         val visi=  visibilitylistofspecificnodeedges.filter(x=>x._2==firstnode)
         val  probs = (quntum_pheromone(x._1.toInt-1) * link_pheromone(0)._3 * visi(0)._3) / denominator
         probabilityofnode=probabilityofnode:+((probs,firstnode.toInt)) 
         }
       
         // Finding next node and path
           var nextnode =(0.0,-1)
           nextnode = probabilityofnode(0)
           for(j<-0 until probabilityofnode.length)
           {

             if(path.contains(nextnode._2))
             {
               nextnode = probabilityofnode(j)
             }
             else
             {
                  if(!path.contains(probabilityofnode(j)._2))
                  {
                      if(probabilityofnode(j)._1> nextnode._1)
                      {
                            nextnode= probabilityofnode(j)
                      }
                 }
             }
           }
        val s = nodes_list.filter(x=>x._1==nextnode._2)    
        if(!s.isEmpty)
        {
            path= path:+ nextnode._2
          source_node = nodes_list.filter(v => v._1 == nextnode._2).toBuffer(0)
        }
         }

       // Finding fitness
          for(i<-0 until path.length)
       {
         val outdegreeofnode = _degree.filter(e => e._1==path(i))(0)._2
         totaloutdegree = totaloutdegree + outdegreeofnode
       }
       fitness = totaloutdegree.toDouble/path.length.toDouble
       fitnessofpaths = fitnessofpaths:+ ((fitness,path))  
       
       // Updating Link Pheromone
       for(i<-0 until path.length-1)
       {
         val weightofanedge = edgeweight.filter(e => e._1 == path(i) && e._2 ==path(i+1))(0)._3
        totalpheromone = totalpheromone + weightofanedge
       }
       divider = 1/totalpheromone
       var oldpheromone = 0.0
       var newpheromone = 0.0
         for(i<-0 until path.length-1)
       {
       oldpheromone = newlink_pheromone.filter(e => e._1 == path(i) && e._2 ==path(i+1))(0)._3
       newpheromone = 0.9* oldpheromone + divider
       val index = newlink_pheromone.indexOf((path(i), path(i+1), oldpheromone))
       newlink_pheromone = newlink_pheromone.updated(index, (path(i),path(i+1), newpheromone))
       }

        link_pheromone = newlink_pheromone
   // Finding and Updating Quantum Pheromone 
  var random = new Random()
   for(i <- 0 to path.length-1)
   {
    
        var theta = 0.0
       var alpha = quntum_pheromone(path(i)-1)
       var beta = sqrt(1 - pow(alpha,2))
      var delta_theta = (((1 + random.nextInt(8)).toFloat/100.toFloat)*3.1428571)
       if((alpha*beta)>0)
       {
          theta = delta_theta * 1
       }
       else if((alpha*beta)<0)
       {
          theta = delta_theta * -1
       }
       else if((alpha*beta)==0)
       {
          theta = 0
       }
       
       alpha = (cos(theta) * alpha) - (sin(theta) * beta)
       beta  = (sin(theta) * alpha) + (cos(theta) * beta)
       
       if(alpha>=beta)
       {
         quntum_pheromone(path(i)-1) = alpha
       }
       else
       {
         quntum_pheromone(path(i)-1) = beta
       }
     }

        val l = Iterator(path.length)   

       l}.collect()

     i=i+1
   
} 
     
   // Findind Score
      edge.mapPartitions{x=>
      val lis = x.toList
      for(i<-0 until lis.length){
      val x = lis(i)
      val link_value = link_pheromone.filter(e => e._1 == x.srcId && e._2 == x.dstId)(0)._3
      val visibilityoflink = visibilitylist.filter(e => e._1 == x.srcId && e._2 == x.dstId)(0)._3
      link_score = link_score:+ (x.srcId.toInt, x.dstId.toInt, link_value + visibilityoflink)
                    }

 x   }.collect()

     
    
  }
  
}
